'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var walletAdapterBase = require('@solana/wallet-adapter-base');
var web3_js = require('@solana/web3.js');
var mobileWalletAdapterProtocolWeb3js = require('@solana-mobile/mobile-wallet-adapter-protocol-web3js');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function toUint8Array(base64EncodedByteArray) {
    return new Uint8Array(window
        .atob(base64EncodedByteArray)
        .split('')
        .map((c) => c.charCodeAt(0)));
}

function getIsSupported() {
    return (typeof window !== 'undefined' &&
        window.isSecureContext &&
        typeof document !== 'undefined' &&
        /android/i.test(navigator.userAgent));
}

const SolanaMobileWalletAdapterWalletName = 'Mobile Wallet Adapter';
const SIGNATURE_LENGTH_IN_BYTES = 64;
function getPublicKeyFromAddress(address) {
    const publicKeyByteArray = toUint8Array(address);
    return new web3_js.PublicKey(publicKeyByteArray);
}
function isVersionedTransaction(transaction) {
    return 'version' in transaction;
}
class SolanaMobileWalletAdapter extends walletAdapterBase.BaseSignInMessageSignerWalletAdapter {
    constructor(config) {
        var _a;
        super();
        this.supportedTransactionVersions = new Set(
        // FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.
        ['legacy', 0]);
        this.name = SolanaMobileWalletAdapterWalletName;
        this.url = 'https://solanamobile.com/wallets';
        this.icon = 'data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==';
        this._connecting = false;
        /**
         * Every time the connection is recycled in some way (eg. `disconnect()` is called)
         * increment this and use it to make sure that `transact` calls from the previous
         * 'generation' don't continue to do work and throw exceptions.
         */
        this._connectionGeneration = 0;
        this._readyState = getIsSupported() ? walletAdapterBase.WalletReadyState.Loadable : walletAdapterBase.WalletReadyState.Unsupported;
        this._authorizationResultCache = config.authorizationResultCache;
        this._addressSelector = config.addressSelector;
        this._appIdentity = config.appIdentity;
        this._chain = (_a = config.chain) !== null && _a !== void 0 ? _a : config.cluster;
        this._onWalletNotFound = config.onWalletNotFound;
        if (this._readyState !== walletAdapterBase.WalletReadyState.Unsupported) {
            this._authorizationResultCache.get().then((authorizationResult) => {
                if (authorizationResult) {
                    // Having a prior authorization result is, right now, the best
                    // indication that a mobile wallet is installed. There is no API
                    // we can use to test for whether the association URI is supported.
                    this.declareWalletAsInstalled();
                }
            });
        }
    }
    get publicKey() {
        if (this._publicKey == null && this._selectedAddress != null) {
            try {
                this._publicKey = getPublicKeyFromAddress(this._selectedAddress);
            }
            catch (e) {
                throw new walletAdapterBase.WalletPublicKeyError((e instanceof Error && (e === null || e === void 0 ? void 0 : e.message)) || 'Unknown error', e);
            }
        }
        return this._publicKey ? this._publicKey : null;
    }
    get connected() {
        return !!this._authorizationResult;
    }
    get connecting() {
        return this._connecting;
    }
    get readyState() {
        return this._readyState;
    }
    declareWalletAsInstalled() {
        if (this._readyState !== walletAdapterBase.WalletReadyState.Installed) {
            this.emit('readyStateChange', (this._readyState = walletAdapterBase.WalletReadyState.Installed));
        }
    }
    runWithGuard(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield callback();
            }
            catch (e) {
                this.emit('error', e);
                throw e;
            }
        });
    }
    /** @deprecated Use `autoConnect()` instead. */
    autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.autoConnect();
        });
    }
    autoConnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.connecting || this.connected) {
                return;
            }
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {
                if (this._readyState !== walletAdapterBase.WalletReadyState.Installed && this._readyState !== walletAdapterBase.WalletReadyState.Loadable) {
                    throw new walletAdapterBase.WalletNotReadyError();
                }
                this._connecting = true;
                try {
                    const cachedAuthorizationResult = yield this._authorizationResultCache.get();
                    if (cachedAuthorizationResult) {
                        // TODO: Evaluate whether there's any threat to not `awaiting` this expression
                        this.handleAuthorizationResult(cachedAuthorizationResult);
                    }
                }
                catch (e) {
                    throw new walletAdapterBase.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);
                }
                finally {
                    this._connecting = false;
                }
            }));
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.connecting || this.connected) {
                return;
            }
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {
                if (this._readyState !== walletAdapterBase.WalletReadyState.Installed && this._readyState !== walletAdapterBase.WalletReadyState.Loadable) {
                    throw new walletAdapterBase.WalletNotReadyError();
                }
                this._connecting = true;
                try {
                    yield this.performAuthorization();
                }
                catch (e) {
                    throw new walletAdapterBase.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);
                }
                finally {
                    this._connecting = false;
                }
            }));
        });
    }
    performAuthorization(signInPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const cachedAuthorizationResult = yield this._authorizationResultCache.get();
                if (cachedAuthorizationResult) {
                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression
                    this.handleAuthorizationResult(cachedAuthorizationResult);
                    return cachedAuthorizationResult;
                }
                return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {
                    const authorizationResult = yield wallet.authorize({
                        chain: this._chain,
                        identity: this._appIdentity,
                        sign_in_payload: signInPayload,
                    });
                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression
                    Promise.all([
                        this._authorizationResultCache.set(authorizationResult),
                        this.handleAuthorizationResult(authorizationResult),
                    ]);
                    return authorizationResult;
                }));
            }
            catch (e) {
                throw new walletAdapterBase.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);
            }
        });
    }
    handleAuthorizationResult(authorizationResult) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const didPublicKeysChange = 
            // Case 1: We started from having no authorization.
            this._authorizationResult == null ||
                // Case 2: The number of authorized accounts changed.
                ((_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorizationResult.accounts.length ||
                // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.
                this._authorizationResult.accounts.some((account, ii) => account.address !== authorizationResult.accounts[ii].address);
            this._authorizationResult = authorizationResult;
            this.declareWalletAsInstalled();
            if (didPublicKeysChange) {
                const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({ address }) => address));
                if (nextSelectedAddress !== this._selectedAddress) {
                    this._selectedAddress = nextSelectedAddress;
                    delete this._publicKey;
                    this.emit('connect', 
                    // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this.publicKey);
                }
            }
        });
    }
    performReauthorization(wallet, authToken) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const authorizationResult = yield wallet.authorize({
                    auth_token: authToken,
                    identity: this._appIdentity,
                });
                // TODO: Evaluate whether there's any threat to not `awaiting` this expression
                Promise.all([
                    this._authorizationResultCache.set(authorizationResult),
                    this.handleAuthorizationResult(authorizationResult),
                ]);
            }
            catch (e) {
                this.disconnect();
                throw new walletAdapterBase.WalletDisconnectedError((e instanceof Error && (e === null || e === void 0 ? void 0 : e.message)) || 'Unknown error', e);
            }
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this._authorizationResultCache.clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression
            this._connecting = false;
            this._connectionGeneration++;
            delete this._authorizationResult;
            delete this._publicKey;
            delete this._selectedAddress;
            this.emit('disconnect');
        });
    }
    transact(callback) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const walletUriBase = (_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.wallet_uri_base;
            const config = walletUriBase ? { baseUri: walletUriBase } : undefined;
            const currentConnectionGeneration = this._connectionGeneration;
            try {
                return yield mobileWalletAdapterProtocolWeb3js.transact(callback, config);
            }
            catch (e) {
                if (this._connectionGeneration !== currentConnectionGeneration) {
                    yield new Promise(() => { }); // Never resolve.
                }
                if (e instanceof Error &&
                    e.name === 'SolanaMobileWalletAdapterError' &&
                    e.code === 'ERROR_WALLET_NOT_FOUND') {
                    yield this._onWalletNotFound(this);
                }
                throw e;
            }
        });
    }
    assertIsAuthorized() {
        if (!this._authorizationResult || !this._selectedAddress)
            throw new walletAdapterBase.WalletNotConnectedError();
        return {
            authToken: this._authorizationResult.auth_token,
            selectedAddress: this._selectedAddress,
        };
    }
    performSignTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            const { authToken } = this.assertIsAuthorized();
            try {
                return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {
                    yield this.performReauthorization(wallet, authToken);
                    const signedTransactions = yield wallet.signTransactions({
                        transactions,
                    });
                    return signedTransactions;
                }));
            }
            catch (error) {
                throw new walletAdapterBase.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);
            }
        });
    }
    sendTransaction(transaction, connection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {
                const { authToken } = this.assertIsAuthorized();
                const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;
                try {
                    return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {
                        function getTargetCommitment() {
                            let targetCommitment;
                            switch (connection.commitment) {
                                case 'confirmed':
                                case 'finalized':
                                case 'processed':
                                    targetCommitment = connection.commitment;
                                    break;
                                default:
                                    targetCommitment = 'finalized';
                            }
                            let targetPreflightCommitment;
                            switch (options === null || options === void 0 ? void 0 : options.preflightCommitment) {
                                case 'confirmed':
                                case 'finalized':
                                case 'processed':
                                    targetPreflightCommitment = options.preflightCommitment;
                                    break;
                                case undefined:
                                    targetPreflightCommitment = targetCommitment;
                                    break;
                                default:
                                    targetPreflightCommitment = 'finalized';
                            }
                            const preflightCommitmentScore = targetPreflightCommitment === 'finalized'
                                ? 2
                                : targetPreflightCommitment === 'confirmed'
                                    ? 1
                                    : 0;
                            const targetCommitmentScore = targetCommitment === 'finalized' ? 2 : targetCommitment === 'confirmed' ? 1 : 0;
                            return preflightCommitmentScore < targetCommitmentScore
                                ? targetPreflightCommitment
                                : targetCommitment;
                        }
                        const [capabilities, _1, _2] = yield Promise.all([
                            wallet.getCapabilities(),
                            this.performReauthorization(wallet, authToken),
                            isVersionedTransaction(transaction)
                                ? null
                                : /**
                                   * Unlike versioned transactions, legacy `Transaction` objects
                                   * may not have an associated `feePayer` or `recentBlockhash`.
                                   * This code exists to patch them up in case they are missing.
                                   */
                                    (() => __awaiter(this, void 0, void 0, function* () {
                                        var _a;
                                        transaction.feePayer || (transaction.feePayer = (_a = this.publicKey) !== null && _a !== void 0 ? _a : undefined);
                                        if (transaction.recentBlockhash == null) {
                                            const { blockhash } = yield connection.getLatestBlockhash({
                                                commitment: getTargetCommitment(),
                                            });
                                            transaction.recentBlockhash = blockhash;
                                        }
                                    }))(),
                        ]);
                        if (capabilities.supports_sign_and_send_transactions) {
                            const signatures = yield wallet.signAndSendTransactions({
                                minContextSlot,
                                transactions: [transaction],
                            });
                            return signatures[0];
                        }
                        else {
                            const [signedTransaction] = yield wallet.signTransactions({
                                transactions: [transaction],
                            });
                            if (isVersionedTransaction(signedTransaction)) {
                                return yield connection.sendTransaction(signedTransaction);
                            }
                            else {
                                const serializedTransaction = signedTransaction.serialize();
                                return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), { preflightCommitment: getTargetCommitment() }));
                            }
                        }
                    }));
                }
                catch (error) {
                    throw new walletAdapterBase.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);
                }
            }));
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {
                const [signedTransaction] = yield this.performSignTransactions([transaction]);
                return signedTransaction;
            }));
        });
    }
    signAllTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {
                const signedTransactions = yield this.performSignTransactions(transactions);
                return signedTransactions;
            }));
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {
                const { authToken, selectedAddress } = this.assertIsAuthorized();
                try {
                    return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {
                        yield this.performReauthorization(wallet, authToken);
                        const [signedMessage] = yield wallet.signMessages({
                            addresses: [selectedAddress],
                            payloads: [message],
                        });
                        const signature = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES);
                        return signature;
                    }));
                }
                catch (error) {
                    throw new walletAdapterBase.WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);
                }
            }));
        });
    }
    signIn(input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                if (this._readyState !== walletAdapterBase.WalletReadyState.Installed && this._readyState !== walletAdapterBase.WalletReadyState.Loadable) {
                    throw new walletAdapterBase.WalletNotReadyError();
                }
                this._connecting = true;
                try {
                    const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), { domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host }));
                    if (!authorizationResult.sign_in_result) {
                        throw new Error("Sign in failed, no sign in result returned by wallet");
                    }
                    const signedInAddress = authorizationResult.sign_in_result.address;
                    const signedInAccount = Object.assign(Object.assign({}, (_b = authorizationResult.accounts.find(acc => acc.address == signedInAddress)) !== null && _b !== void 0 ? _b : {
                        address: signedInAddress
                    }), { publicKey: toUint8Array(signedInAddress) });
                    return {
                        account: signedInAccount,
                        signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),
                        signature: toUint8Array(authorizationResult.sign_in_result.signature)
                    };
                }
                catch (e) {
                    throw new walletAdapterBase.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);
                }
                finally {
                    this._connecting = false;
                }
            }));
        });
    }
}

function createDefaultAddressSelector() {
    return {
        select(addresses) {
            return __awaiter(this, void 0, void 0, function* () {
                return addresses[0];
            });
        },
    };
}

const CACHE_KEY = 'SolanaMobileWalletAdapterDefaultAuthorizationCache';
function createDefaultAuthorizationResultCache() {
    let storage;
    try {
        storage = window.localStorage;
        // eslint-disable-next-line no-empty
    }
    catch (_a) { }
    return {
        clear() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!storage) {
                    return;
                }
                try {
                    storage.removeItem(CACHE_KEY);
                    // eslint-disable-next-line no-empty
                }
                catch (_a) { }
            });
        },
        get() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!storage) {
                    return;
                }
                try {
                    return JSON.parse(storage.getItem(CACHE_KEY)) || undefined;
                    // eslint-disable-next-line no-empty
                }
                catch (_a) { }
            });
        },
        set(authorizationResult) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!storage) {
                    return;
                }
                try {
                    storage.setItem(CACHE_KEY, JSON.stringify(authorizationResult));
                    // eslint-disable-next-line no-empty
                }
                catch (_a) { }
            });
        },
    };
}

function defaultWalletNotFoundHandler(mobileWalletAdapter) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof window !== 'undefined') {
            window.location.assign(mobileWalletAdapter.url);
        }
    });
}
function createDefaultWalletNotFoundHandler() {
    return defaultWalletNotFoundHandler;
}

exports.SolanaMobileWalletAdapter = SolanaMobileWalletAdapter;
exports.SolanaMobileWalletAdapterWalletName = SolanaMobileWalletAdapterWalletName;
exports.createDefaultAddressSelector = createDefaultAddressSelector;
exports.createDefaultAuthorizationResultCache = createDefaultAuthorizationResultCache;
exports.createDefaultWalletNotFoundHandler = createDefaultWalletNotFoundHandler;
